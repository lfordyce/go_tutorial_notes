// Code generated by ___TestCpixSchemaGen_in_github_com_lfordyce_generalNotes_xml_utils_cpix__5_.test. DO NOT EDIT.

package cpix

import (
	"bytes"
	"encoding/base64"
	"encoding/xml"
	"time"
)

type AgreementMethodType struct {
	Items             []string    `xml:",any"`
	OriginatorKeyInfo KeyInfoType `xml:"http://www.w3.org/2000/09/xmldsig# OriginatorKeyInfo,omitempty"`
	RecipientKeyInfo  KeyInfoType `xml:"http://www.w3.org/2000/09/xmldsig# RecipientKeyInfo,omitempty"`
	Algorithm         string      `xml:"Algorithm,attr"`
}

type AlgorithmParametersType struct {
	Suite           string           `xml:"urn:ietf:params:xml:ns:keyprov:pskc Suite,omitempty"`
	ChallengeFormat ChallengeFormat  `xml:"urn:ietf:params:xml:ns:keyprov:pskc ChallengeFormat,omitempty"`
	ResponseFormat  ResponseFormat   `xml:"urn:ietf:params:xml:ns:keyprov:pskc ResponseFormat,omitempty"`
	Extensions      []ExtensionsType `xml:"urn:ietf:params:xml:ns:keyprov:pskc Extensions,omitempty"`
}

type AudioFilterType struct {
	MinChannels int `xml:"minChannels,attr,omitempty"`
	MaxChannels int `xml:"maxChannels,attr,omitempty"`
}

type BinaryDataType struct {
	PlainValue     []byte            `xml:"urn:ietf:params:xml:ns:keyprov:pskc PlainValue"`
	EncryptedValue EncryptedDataType `xml:"http://www.w3.org/2001/04/xmlenc# EncryptedValue"`
	ValueMAC       []byte            `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
}

func (t *BinaryDataType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T BinaryDataType
	var layout struct {
		*T
		PlainValue *xsdBase64Binary `xml:"urn:ietf:params:xml:ns:keyprov:pskc PlainValue"`
		ValueMAC   *xsdBase64Binary `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
	}
	layout.T = (*T)(t)
	layout.PlainValue = (*xsdBase64Binary)(&layout.T.PlainValue)
	layout.ValueMAC = (*xsdBase64Binary)(&layout.T.ValueMAC)
	return e.EncodeElement(layout, start)
}
func (t *BinaryDataType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T BinaryDataType
	var overlay struct {
		*T
		PlainValue *xsdBase64Binary `xml:"urn:ietf:params:xml:ns:keyprov:pskc PlainValue"`
		ValueMAC   *xsdBase64Binary `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.PlainValue = (*xsdBase64Binary)(&overlay.T.PlainValue)
	overlay.ValueMAC = (*xsdBase64Binary)(&overlay.T.ValueMAC)
	return d.DecodeElement(&overlay, &start)
}

type BitrateFilterType struct {
	MinBitrate int `xml:"minBitrate,attr,omitempty"`
	MaxBitrate int `xml:"maxBitrate,attr,omitempty"`
}

type CanonicalizationMethodType struct {
	Items     []string `xml:",any"`
	Algorithm string   `xml:"Algorithm,attr"`
}

// May be no more than 4 items long
type CencSchemeType string

type ChallengeFormat struct {
	Encoding    ValueFormatType `xml:"Encoding,attr"`
	Min         uint            `xml:"Min,attr"`
	Max         uint            `xml:"Max,attr"`
	CheckDigits bool            `xml:"CheckDigits,attr,omitempty"`
}

func (t *ChallengeFormat) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ChallengeFormat
	var overlay struct {
		*T
		CheckDigits *bool `xml:"CheckDigits,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.CheckDigits = (*bool)(&overlay.T.CheckDigits)
	return d.DecodeElement(&overlay, &start)
}

type CipherDataType struct {
	CipherValue     []byte `xml:"http://www.w3.org/2001/04/xmlenc# CipherValue"`
	CipherReference string `xml:"http://www.w3.org/2001/04/xmlenc# CipherReference"`
}

func (t *CipherDataType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T CipherDataType
	var layout struct {
		*T
		CipherValue *xsdBase64Binary `xml:"http://www.w3.org/2001/04/xmlenc# CipherValue"`
	}
	layout.T = (*T)(t)
	layout.CipherValue = (*xsdBase64Binary)(&layout.T.CipherValue)
	return e.EncodeElement(layout, start)
}
func (t *CipherDataType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T CipherDataType
	var overlay struct {
		*T
		CipherValue *xsdBase64Binary `xml:"http://www.w3.org/2001/04/xmlenc# CipherValue"`
	}
	overlay.T = (*T)(t)
	overlay.CipherValue = (*xsdBase64Binary)(&overlay.T.CipherValue)
	return d.DecodeElement(&overlay, &start)
}

type CipherReferenceType struct {
	Transforms TransformsType `xml:"http://www.w3.org/2001/04/xmlenc# Transforms,omitempty"`
	URI        string         `xml:"URI,attr"`
}

type ContentKeyListType struct {
	ContentKey    []ContentKeyType `xml:"urn:dashif:org:cpix ContentKey,omitempty"`
	Id            string           `xml:"id,attr,omitempty"`
	UpdateVersion int              `xml:"updateVersion,attr,omitempty"`
}

type ContentKeyPeriodListType struct {
	ContentKeyPeriod []ContentKeyPeriodType `xml:"urn:dashif:org:cpix ContentKeyPeriod,omitempty"`
	Id               string                 `xml:"id,attr,omitempty"`
	UpdateVersion    int                    `xml:"updateVersion,attr,omitempty"`
}

type ContentKeyPeriodType struct {
	Id    string    `xml:"id,attr,omitempty"`
	Index int       `xml:"index,attr,omitempty"`
	Start time.Time `xml:"start,attr,omitempty"`
	End   time.Time `xml:"end,attr,omitempty"`
}

func (t *ContentKeyPeriodType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T ContentKeyPeriodType
	var layout struct {
		*T
		Start *xsdDateTime `xml:"start,attr,omitempty"`
		End   *xsdDateTime `xml:"end,attr,omitempty"`
	}
	layout.T = (*T)(t)
	layout.Start = (*xsdDateTime)(&layout.T.Start)
	layout.End = (*xsdDateTime)(&layout.T.End)
	return e.EncodeElement(layout, start)
}
func (t *ContentKeyPeriodType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ContentKeyPeriodType
	var overlay struct {
		*T
		Start *xsdDateTime `xml:"start,attr,omitempty"`
		End   *xsdDateTime `xml:"end,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Start = (*xsdDateTime)(&overlay.T.Start)
	overlay.End = (*xsdDateTime)(&overlay.T.End)
	return d.DecodeElement(&overlay, &start)
}

type ContentKeyType struct {
	Issuer                 string                  `xml:"urn:dashif:org:cpix Issuer,omitempty"`
	AlgorithmParameters    AlgorithmParametersType `xml:"urn:ietf:params:xml:ns:keyprov:pskc AlgorithmParameters,omitempty"`
	KeyProfileId           string                  `xml:"urn:dashif:org:cpix KeyProfileId,omitempty"`
	KeyReference           string                  `xml:"urn:dashif:org:cpix KeyReference,omitempty"`
	FriendlyName           string                  `xml:"urn:dashif:org:cpix FriendlyName,omitempty"`
	Data                   KeyDataType             `xml:"urn:ietf:params:xml:ns:keyprov:pskc Data,omitempty"`
	UserId                 string                  `xml:"urn:dashif:org:cpix UserId,omitempty"`
	Policy                 PolicyType              `xml:"urn:ietf:params:xml:ns:keyprov:pskc Policy,omitempty"`
	Extensions             []ExtensionsType        `xml:"urn:ietf:params:xml:ns:keyprov:pskc Extensions,omitempty"`
	Kid                    KeyIdType               `xml:"kid,attr"`
	ExplicitIV             []byte                  `xml:"explicitIV,attr,omitempty"`
	DependsOnKey           string                  `xml:"dependsOnKey,attr,omitempty"`
	CommonEncryptionScheme CencSchemeType          `xml:"commonEncryptionScheme,attr,omitempty"`
	Id                     string                  `xml:"id,attr,omitempty"`
	Algorithm              string                  `xml:"Algorithm,attr,omitempty"`
}

func (t *ContentKeyType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T ContentKeyType
	var layout struct {
		*T
		ExplicitIV *xsdBase64Binary `xml:"explicitIV,attr,omitempty"`
	}
	layout.T = (*T)(t)
	layout.ExplicitIV = (*xsdBase64Binary)(&layout.T.ExplicitIV)
	return e.EncodeElement(layout, start)
}
func (t *ContentKeyType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ContentKeyType
	var overlay struct {
		*T
		ExplicitIV *xsdBase64Binary `xml:"explicitIV,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.ExplicitIV = (*xsdBase64Binary)(&overlay.T.ExplicitIV)
	return d.DecodeElement(&overlay, &start)
}

type ContentKeyUsageRuleListType struct {
	ContentKeyUsageRule []ContentKeyUsageRuleType `xml:"urn:dashif:org:cpix ContentKeyUsageRule,omitempty"`
	Id                  string                    `xml:"id,attr,omitempty"`
	UpdateVersion       int                       `xml:"updateVersion,attr,omitempty"`
}

type ContentKeyUsageRuleType struct {
	Items             []string              `xml:",any"`
	KeyPeriodFilter   []KeyPeriodFilterType `xml:"urn:dashif:org:cpix KeyPeriodFilter,omitempty"`
	LabelFilter       []LabelFilterType     `xml:"urn:dashif:org:cpix LabelFilter,omitempty"`
	VideoFilter       []VideoFilterType     `xml:"urn:dashif:org:cpix VideoFilter,omitempty"`
	AudioFilter       []AudioFilterType     `xml:"urn:dashif:org:cpix AudioFilter,omitempty"`
	BitrateFilter     []BitrateFilterType   `xml:"urn:dashif:org:cpix BitrateFilter,omitempty"`
	Id                string                `xml:"id,attr,omitempty"`
	Kid               string                `xml:"kid,attr"`
	IntendedTrackType string                `xml:"intendedTrackType,attr,omitempty"`
}

type CpixType struct {
	DeliveryDataList        DeliveryDataListType        `xml:"urn:dashif:org:cpix DeliveryDataList,omitempty"`
	ContentKeyList          ContentKeyListType          `xml:"urn:dashif:org:cpix ContentKeyList,omitempty"`
	DRMSystemList           DRMSystemListType           `xml:"urn:dashif:org:cpix DRMSystemList,omitempty"`
	ContentKeyPeriodList    ContentKeyPeriodListType    `xml:"urn:dashif:org:cpix ContentKeyPeriodList,omitempty"`
	ContentKeyUsageRuleList ContentKeyUsageRuleListType `xml:"urn:dashif:org:cpix ContentKeyUsageRuleList,omitempty"`
	UpdateHistoryItemList   UpdateHistoryItemListType   `xml:"urn:dashif:org:cpix UpdateHistoryItemList,omitempty"`
	Signature               []string                    `xml:"urn:dashif:org:cpix Signature,omitempty"`
	Id                      string                      `xml:"id,attr,omitempty"`
	ContentId               string                      `xml:"contentId,attr,omitempty"`
	Name                    string                      `xml:"name,attr,omitempty"`
	Version                 string                      `xml:"version,attr,omitempty"`
}

type CryptoBinary []byte

func (t *CryptoBinary) UnmarshalText(text []byte) error {
	return (*xsdBase64Binary)(t).UnmarshalText(text)
}
func (t CryptoBinary) MarshalText() ([]byte, error) {
	return xsdBase64Binary(t).MarshalText()
}

type CryptoModuleInfoType struct {
	Id         string           `xml:"urn:ietf:params:xml:ns:keyprov:pskc Id"`
	Extensions []ExtensionsType `xml:"urn:ietf:params:xml:ns:keyprov:pskc Extensions,omitempty"`
}

type DRMSystemListType struct {
	DRMSystem     []DRMSystemType `xml:"urn:dashif:org:cpix DRMSystem,omitempty"`
	Id            string          `xml:"id,attr,omitempty"`
	UpdateVersion int             `xml:"updateVersion,attr,omitempty"`
}

type DRMSystemType struct {
	Items                               []string               `xml:",any"`
	PSSH                                []byte                 `xml:"urn:dashif:org:cpix PSSH,omitempty"`
	ContentProtectionData               []byte                 `xml:"urn:dashif:org:cpix ContentProtectionData,omitempty"`
	URIExtXKey                          []byte                 `xml:"urn:dashif:org:cpix URIExtXKey,omitempty"`
	HLSSignalingData                    []HLSSignalingDataType `xml:"urn:dashif:org:cpix HLSSignalingData,omitempty"`
	SmoothStreamingProtectionHeaderData string                 `xml:"urn:dashif:org:cpix SmoothStreamingProtectionHeaderData,omitempty"`
	HDSSignalingData                    []byte                 `xml:"urn:dashif:org:cpix HDSSignalingData,omitempty"`
	Id                                  string                 `xml:"id,attr,omitempty"`
	UpdateVersion                       int                    `xml:"updateVersion,attr,omitempty"`
	SystemId                            string                 `xml:"systemId,attr"`
	Kid                                 string                 `xml:"kid,attr"`
	Name                                string                 `xml:"name,attr,omitempty"`
}

func (t *DRMSystemType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T DRMSystemType
	var layout struct {
		*T
		PSSH                  *xsdBase64Binary `xml:"urn:dashif:org:cpix PSSH,omitempty"`
		ContentProtectionData *xsdBase64Binary `xml:"urn:dashif:org:cpix ContentProtectionData,omitempty"`
		URIExtXKey            *xsdBase64Binary `xml:"urn:dashif:org:cpix URIExtXKey,omitempty"`
		HDSSignalingData      *xsdBase64Binary `xml:"urn:dashif:org:cpix HDSSignalingData,omitempty"`
	}
	layout.T = (*T)(t)
	layout.PSSH = (*xsdBase64Binary)(&layout.T.PSSH)
	layout.ContentProtectionData = (*xsdBase64Binary)(&layout.T.ContentProtectionData)
	layout.URIExtXKey = (*xsdBase64Binary)(&layout.T.URIExtXKey)
	layout.HDSSignalingData = (*xsdBase64Binary)(&layout.T.HDSSignalingData)
	return e.EncodeElement(layout, start)
}
func (t *DRMSystemType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T DRMSystemType
	var overlay struct {
		*T
		PSSH                  *xsdBase64Binary `xml:"urn:dashif:org:cpix PSSH,omitempty"`
		ContentProtectionData *xsdBase64Binary `xml:"urn:dashif:org:cpix ContentProtectionData,omitempty"`
		URIExtXKey            *xsdBase64Binary `xml:"urn:dashif:org:cpix URIExtXKey,omitempty"`
		HDSSignalingData      *xsdBase64Binary `xml:"urn:dashif:org:cpix HDSSignalingData,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.PSSH = (*xsdBase64Binary)(&overlay.T.PSSH)
	overlay.ContentProtectionData = (*xsdBase64Binary)(&overlay.T.ContentProtectionData)
	overlay.URIExtXKey = (*xsdBase64Binary)(&overlay.T.URIExtXKey)
	overlay.HDSSignalingData = (*xsdBase64Binary)(&overlay.T.HDSSignalingData)
	return d.DecodeElement(&overlay, &start)
}

type DSAKeyValueType struct {
	P           CryptoBinary `xml:"http://www.w3.org/2000/09/xmldsig# P"`
	Q           CryptoBinary `xml:"http://www.w3.org/2000/09/xmldsig# Q"`
	G           CryptoBinary `xml:"http://www.w3.org/2000/09/xmldsig# G,omitempty"`
	Y           CryptoBinary `xml:"http://www.w3.org/2000/09/xmldsig# Y"`
	J           CryptoBinary `xml:"http://www.w3.org/2000/09/xmldsig# J,omitempty"`
	Seed        CryptoBinary `xml:"http://www.w3.org/2000/09/xmldsig# Seed"`
	PgenCounter CryptoBinary `xml:"http://www.w3.org/2000/09/xmldsig# PgenCounter"`
}

type DeliveryDataListType struct {
	DeliveryData  []DeliveryDataType `xml:"urn:dashif:org:cpix DeliveryData,omitempty"`
	Id            string             `xml:"id,attr,omitempty"`
	UpdateVersion int                `xml:"updateVersion,attr,omitempty"`
}

type DeliveryDataType struct {
	DeliveryKey          KeyInfoType   `xml:"http://www.w3.org/2000/09/xmldsig# DeliveryKey"`
	DocumentKey          KeyType       `xml:"urn:dashif:org:cpix DocumentKey"`
	MACMethod            MACMethodType `xml:"urn:ietf:params:xml:ns:keyprov:pskc MACMethod,omitempty"`
	Description          string        `xml:"urn:dashif:org:cpix Description,omitempty"`
	SendingEntity        string        `xml:"urn:dashif:org:cpix SendingEntity,omitempty"`
	SenderPointOfContact string        `xml:"urn:dashif:org:cpix SenderPointOfContact,omitempty"`
	ReceivingEntity      string        `xml:"urn:dashif:org:cpix ReceivingEntity,omitempty"`
	Id                   string        `xml:"id,attr,omitempty"`
	UpdateVersion        int           `xml:"updateVersion,attr,omitempty"`
	Name                 string        `xml:"name,attr,omitempty"`
}

type DeviceInfoType struct {
	Manufacturer  string           `xml:"urn:ietf:params:xml:ns:keyprov:pskc Manufacturer,omitempty"`
	SerialNo      string           `xml:"urn:ietf:params:xml:ns:keyprov:pskc SerialNo,omitempty"`
	Model         string           `xml:"urn:ietf:params:xml:ns:keyprov:pskc Model,omitempty"`
	IssueNo       string           `xml:"urn:ietf:params:xml:ns:keyprov:pskc IssueNo,omitempty"`
	DeviceBinding string           `xml:"urn:ietf:params:xml:ns:keyprov:pskc DeviceBinding,omitempty"`
	StartDate     time.Time        `xml:"urn:ietf:params:xml:ns:keyprov:pskc StartDate,omitempty"`
	ExpiryDate    time.Time        `xml:"urn:ietf:params:xml:ns:keyprov:pskc ExpiryDate,omitempty"`
	UserId        string           `xml:"urn:ietf:params:xml:ns:keyprov:pskc UserId,omitempty"`
	Extensions    []ExtensionsType `xml:"urn:ietf:params:xml:ns:keyprov:pskc Extensions,omitempty"`
}

func (t *DeviceInfoType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T DeviceInfoType
	var layout struct {
		*T
		StartDate  *xsdDateTime `xml:"urn:ietf:params:xml:ns:keyprov:pskc StartDate,omitempty"`
		ExpiryDate *xsdDateTime `xml:"urn:ietf:params:xml:ns:keyprov:pskc ExpiryDate,omitempty"`
	}
	layout.T = (*T)(t)
	layout.StartDate = (*xsdDateTime)(&layout.T.StartDate)
	layout.ExpiryDate = (*xsdDateTime)(&layout.T.ExpiryDate)
	return e.EncodeElement(layout, start)
}
func (t *DeviceInfoType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T DeviceInfoType
	var overlay struct {
		*T
		StartDate  *xsdDateTime `xml:"urn:ietf:params:xml:ns:keyprov:pskc StartDate,omitempty"`
		ExpiryDate *xsdDateTime `xml:"urn:ietf:params:xml:ns:keyprov:pskc ExpiryDate,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.StartDate = (*xsdDateTime)(&overlay.T.StartDate)
	overlay.ExpiryDate = (*xsdDateTime)(&overlay.T.ExpiryDate)
	return d.DecodeElement(&overlay, &start)
}

type DigestMethodType struct {
	Items     []string `xml:",any"`
	Algorithm string   `xml:"Algorithm,attr"`
}

type DigestValueType []byte

func (t *DigestValueType) UnmarshalText(text []byte) error {
	return (*xsdBase64Binary)(t).UnmarshalText(text)
}
func (t DigestValueType) MarshalText() ([]byte, error) {
	return xsdBase64Binary(t).MarshalText()
}

type EncryptedDataType struct {
	EncryptionMethod     EncryptionMethodType `xml:"http://www.w3.org/2001/04/xmlenc# EncryptionMethod,omitempty"`
	KeyInfo              string               `xml:"http://www.w3.org/2001/04/xmlenc# KeyInfo,omitempty"`
	CipherData           string               `xml:"http://www.w3.org/2001/04/xmlenc# CipherData"`
	EncryptionProperties string               `xml:"http://www.w3.org/2001/04/xmlenc# EncryptionProperties,omitempty"`
	Id                   string               `xml:"Id,attr,omitempty"`
	Type                 string               `xml:"Type,attr,omitempty"`
	MimeType             string               `xml:"MimeType,attr,omitempty"`
	Encoding             string               `xml:"Encoding,attr,omitempty"`
}

type EncryptedKeyType struct {
	EncryptionMethod     EncryptionMethodType `xml:"http://www.w3.org/2001/04/xmlenc# EncryptionMethod,omitempty"`
	KeyInfo              string               `xml:"http://www.w3.org/2001/04/xmlenc# KeyInfo,omitempty"`
	CipherData           string               `xml:"http://www.w3.org/2001/04/xmlenc# CipherData"`
	EncryptionProperties string               `xml:"http://www.w3.org/2001/04/xmlenc# EncryptionProperties,omitempty"`
	ReferenceList        string               `xml:"http://www.w3.org/2001/04/xmlenc# ReferenceList,omitempty"`
	CarriedKeyName       string               `xml:"http://www.w3.org/2001/04/xmlenc# CarriedKeyName,omitempty"`
	Recipient            string               `xml:"Recipient,attr,omitempty"`
	Id                   string               `xml:"Id,attr,omitempty"`
	Type                 string               `xml:"Type,attr,omitempty"`
	MimeType             string               `xml:"MimeType,attr,omitempty"`
	Encoding             string               `xml:"Encoding,attr,omitempty"`
}

type EncryptedType struct {
	EncryptionMethod     EncryptionMethodType `xml:"http://www.w3.org/2001/04/xmlenc# EncryptionMethod,omitempty"`
	KeyInfo              string               `xml:"http://www.w3.org/2001/04/xmlenc# KeyInfo,omitempty"`
	CipherData           string               `xml:"http://www.w3.org/2001/04/xmlenc# CipherData"`
	EncryptionProperties string               `xml:"http://www.w3.org/2001/04/xmlenc# EncryptionProperties,omitempty"`
	Id                   string               `xml:"Id,attr,omitempty"`
	Type                 string               `xml:"Type,attr,omitempty"`
	MimeType             string               `xml:"MimeType,attr,omitempty"`
	Encoding             string               `xml:"Encoding,attr,omitempty"`
}

type EncryptionMethodType struct {
	Items      []string `xml:",any"`
	KeySize    int      `xml:"http://www.w3.org/2001/04/xmlenc# KeySize,omitempty"`
	OAEPparams []byte   `xml:"http://www.w3.org/2001/04/xmlenc# OAEPparams,omitempty"`
	Algorithm  string   `xml:"Algorithm,attr"`
}

func (t *EncryptionMethodType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T EncryptionMethodType
	var layout struct {
		*T
		OAEPparams *xsdBase64Binary `xml:"http://www.w3.org/2001/04/xmlenc# OAEPparams,omitempty"`
	}
	layout.T = (*T)(t)
	layout.OAEPparams = (*xsdBase64Binary)(&layout.T.OAEPparams)
	return e.EncodeElement(layout, start)
}
func (t *EncryptionMethodType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T EncryptionMethodType
	var overlay struct {
		*T
		OAEPparams *xsdBase64Binary `xml:"http://www.w3.org/2001/04/xmlenc# OAEPparams,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.OAEPparams = (*xsdBase64Binary)(&overlay.T.OAEPparams)
	return d.DecodeElement(&overlay, &start)
}

type EncryptionPropertiesType struct {
	EncryptionProperty []string `xml:"http://www.w3.org/2001/04/xmlenc# EncryptionProperty"`
	Id                 string   `xml:"Id,attr,omitempty"`
}

type EncryptionPropertyType struct {
	Item   string `xml:",any"`
	Target string `xml:"Target,attr,omitempty"`
	Id     string `xml:"Id,attr,omitempty"`
}

type ExtensionsType struct {
	Items      []string `xml:",any"`
	Definition string   `xml:"definition,attr,omitempty"`
}

type HLSSignalingDataType struct {
	Value    []byte       `xml:",chardata"`
	Playlist PlaylistType `xml:"playlist,attr,omitempty"`
}

func (t *HLSSignalingDataType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T HLSSignalingDataType
	var layout struct {
		*T
		Value *xsdBase64Binary `xml:",chardata"`
	}
	layout.T = (*T)(t)
	layout.Value = (*xsdBase64Binary)(&layout.T.Value)
	return e.EncodeElement(layout, start)
}
func (t *HLSSignalingDataType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T HLSSignalingDataType
	var overlay struct {
		*T
		Value *xsdBase64Binary `xml:",chardata"`
	}
	overlay.T = (*T)(t)
	overlay.Value = (*xsdBase64Binary)(&overlay.T.Value)
	return d.DecodeElement(&overlay, &start)
}

type IntDataType struct {
	PlainValue     int               `xml:"urn:ietf:params:xml:ns:keyprov:pskc PlainValue"`
	EncryptedValue EncryptedDataType `xml:"http://www.w3.org/2001/04/xmlenc# EncryptedValue"`
	ValueMAC       []byte            `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
}

func (t *IntDataType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T IntDataType
	var layout struct {
		*T
		ValueMAC *xsdBase64Binary `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
	}
	layout.T = (*T)(t)
	layout.ValueMAC = (*xsdBase64Binary)(&layout.T.ValueMAC)
	return e.EncodeElement(layout, start)
}
func (t *IntDataType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T IntDataType
	var overlay struct {
		*T
		ValueMAC *xsdBase64Binary `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.ValueMAC = (*xsdBase64Binary)(&overlay.T.ValueMAC)
	return d.DecodeElement(&overlay, &start)
}

type KeyContainerType struct {
	EncryptionKey KeyInfoType      `xml:"http://www.w3.org/2000/09/xmldsig# EncryptionKey,omitempty"`
	MACMethod     MACMethodType    `xml:"urn:ietf:params:xml:ns:keyprov:pskc MACMethod,omitempty"`
	KeyPackage    []KeyPackageType `xml:"urn:ietf:params:xml:ns:keyprov:pskc KeyPackage"`
	Signature     SignatureType    `xml:"http://www.w3.org/2000/09/xmldsig# Signature,omitempty"`
	Extensions    []ExtensionsType `xml:"urn:ietf:params:xml:ns:keyprov:pskc Extensions,omitempty"`
	Version       VersionType      `xml:"Version,attr"`
	Id            string           `xml:"Id,attr,omitempty"`
}

type KeyDataType struct {
	Items        []string       `xml:",any"`
	Secret       BinaryDataType `xml:"urn:ietf:params:xml:ns:keyprov:pskc Secret,omitempty"`
	Counter      LongDataType   `xml:"urn:ietf:params:xml:ns:keyprov:pskc Counter,omitempty"`
	Time         IntDataType    `xml:"urn:ietf:params:xml:ns:keyprov:pskc Time,omitempty"`
	TimeInterval IntDataType    `xml:"urn:ietf:params:xml:ns:keyprov:pskc TimeInterval,omitempty"`
	TimeDrift    IntDataType    `xml:"urn:ietf:params:xml:ns:keyprov:pskc TimeDrift,omitempty"`
}

// Must match the pattern [A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}
type KeyIdType string

type KeyInfoType struct {
	Item            string `xml:",any"`
	KeyName         string `xml:"http://www.w3.org/2000/09/xmldsig# KeyName"`
	KeyValue        string `xml:"http://www.w3.org/2000/09/xmldsig# KeyValue"`
	RetrievalMethod string `xml:"http://www.w3.org/2000/09/xmldsig# RetrievalMethod"`
	X509Data        string `xml:"http://www.w3.org/2000/09/xmldsig# X509Data"`
	PGPData         string `xml:"http://www.w3.org/2000/09/xmldsig# PGPData"`
	SPKIData        string `xml:"http://www.w3.org/2000/09/xmldsig# SPKIData"`
	MgmtData        string `xml:"http://www.w3.org/2000/09/xmldsig# MgmtData"`
	Id              string `xml:"Id,attr,omitempty"`
}

type KeyPackageType struct {
	DeviceInfo       DeviceInfoType       `xml:"urn:ietf:params:xml:ns:keyprov:pskc DeviceInfo,omitempty"`
	CryptoModuleInfo CryptoModuleInfoType `xml:"urn:ietf:params:xml:ns:keyprov:pskc CryptoModuleInfo,omitempty"`
	Key              KeyType              `xml:"urn:ietf:params:xml:ns:keyprov:pskc Key,omitempty"`
	Extensions       []ExtensionsType     `xml:"urn:ietf:params:xml:ns:keyprov:pskc Extensions,omitempty"`
}

type KeyPeriodFilterType struct {
	PeriodId string `xml:"periodId,attr"`
}

type KeyType struct {
	Issuer              string                  `xml:"urn:ietf:params:xml:ns:keyprov:pskc Issuer,omitempty"`
	AlgorithmParameters AlgorithmParametersType `xml:"urn:ietf:params:xml:ns:keyprov:pskc AlgorithmParameters,omitempty"`
	KeyProfileId        string                  `xml:"urn:ietf:params:xml:ns:keyprov:pskc KeyProfileId,omitempty"`
	KeyReference        string                  `xml:"urn:ietf:params:xml:ns:keyprov:pskc KeyReference,omitempty"`
	FriendlyName        string                  `xml:"urn:ietf:params:xml:ns:keyprov:pskc FriendlyName,omitempty"`
	Data                KeyDataType             `xml:"urn:ietf:params:xml:ns:keyprov:pskc Data,omitempty"`
	UserId              string                  `xml:"urn:ietf:params:xml:ns:keyprov:pskc UserId,omitempty"`
	Policy              PolicyType              `xml:"urn:ietf:params:xml:ns:keyprov:pskc Policy,omitempty"`
	Extensions          []ExtensionsType        `xml:"urn:ietf:params:xml:ns:keyprov:pskc Extensions,omitempty"`
	Id                  string                  `xml:"Id,attr"`
	Algorithm           string                  `xml:"Algorithm,attr,omitempty"`
}

// May be one of OTP, CR, Encrypt, Integrity, Verify, Unlock, Decrypt, KeyWrap, Unwrap, Derive, Generate
type KeyUsageType string

type KeyValueType struct {
	Item        string `xml:",any"`
	DSAKeyValue string `xml:"http://www.w3.org/2000/09/xmldsig# DSAKeyValue"`
	RSAKeyValue string `xml:"http://www.w3.org/2000/09/xmldsig# RSAKeyValue"`
}

type LabelFilterType struct {
	Label string `xml:"label,attr"`
}

type LongDataType struct {
	PlainValue     int64             `xml:"urn:ietf:params:xml:ns:keyprov:pskc PlainValue"`
	EncryptedValue EncryptedDataType `xml:"http://www.w3.org/2001/04/xmlenc# EncryptedValue"`
	ValueMAC       []byte            `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
}

func (t *LongDataType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T LongDataType
	var layout struct {
		*T
		ValueMAC *xsdBase64Binary `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
	}
	layout.T = (*T)(t)
	layout.ValueMAC = (*xsdBase64Binary)(&layout.T.ValueMAC)
	return e.EncodeElement(layout, start)
}
func (t *LongDataType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T LongDataType
	var overlay struct {
		*T
		ValueMAC *xsdBase64Binary `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.ValueMAC = (*xsdBase64Binary)(&overlay.T.ValueMAC)
	return d.DecodeElement(&overlay, &start)
}

type MACMethodType struct {
	Items           []string          `xml:",any"`
	MACKey          EncryptedDataType `xml:"http://www.w3.org/2001/04/xmlenc# MACKey,omitempty"`
	MACKeyReference string            `xml:"urn:ietf:params:xml:ns:keyprov:pskc MACKeyReference,omitempty"`
	Algorithm       string            `xml:"Algorithm,attr"`
}

type ManifestType struct {
	Reference []string `xml:"http://www.w3.org/2000/09/xmldsig# Reference"`
	Id        string   `xml:"Id,attr,omitempty"`
}

type ObjectType struct {
	Item     string `xml:",any"`
	Id       string `xml:"Id,attr,omitempty"`
	MimeType string `xml:"MimeType,attr,omitempty"`
	Encoding string `xml:"Encoding,attr,omitempty"`
}

type PGPDataType struct {
	Items        []string `xml:",any"`
	PGPKeyID     []byte   `xml:"http://www.w3.org/2000/09/xmldsig# PGPKeyID"`
	PGPKeyPacket []byte   `xml:"http://www.w3.org/2000/09/xmldsig# PGPKeyPacket,omitempty"`
}

func (t *PGPDataType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T PGPDataType
	var layout struct {
		*T
		PGPKeyID     *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# PGPKeyID"`
		PGPKeyPacket *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# PGPKeyPacket,omitempty"`
	}
	layout.T = (*T)(t)
	layout.PGPKeyID = (*xsdBase64Binary)(&layout.T.PGPKeyID)
	layout.PGPKeyPacket = (*xsdBase64Binary)(&layout.T.PGPKeyPacket)
	return e.EncodeElement(layout, start)
}
func (t *PGPDataType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T PGPDataType
	var overlay struct {
		*T
		PGPKeyID     *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# PGPKeyID"`
		PGPKeyPacket *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# PGPKeyPacket,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.PGPKeyID = (*xsdBase64Binary)(&overlay.T.PGPKeyID)
	overlay.PGPKeyPacket = (*xsdBase64Binary)(&overlay.T.PGPKeyPacket)
	return d.DecodeElement(&overlay, &start)
}

type PINPolicyType struct {
	PINKeyId          string           `xml:"PINKeyId,attr,omitempty"`
	PINUsageMode      PINUsageModeType `xml:"PINUsageMode,attr,omitempty"`
	MaxFailedAttempts uint             `xml:"MaxFailedAttempts,attr,omitempty"`
	MinLength         uint             `xml:"MinLength,attr,omitempty"`
	MaxLength         uint             `xml:"MaxLength,attr,omitempty"`
	PINEncoding       ValueFormatType  `xml:"PINEncoding,attr,omitempty"`
}

// May be one of Local, Prepend, Append, Algorithmic
type PINUsageModeType string

// May be one of master, media
type PlaylistType string

type PolicyType struct {
	Items                []string       `xml:",any"`
	StartDate            time.Time      `xml:"urn:ietf:params:xml:ns:keyprov:pskc StartDate,omitempty"`
	ExpiryDate           time.Time      `xml:"urn:ietf:params:xml:ns:keyprov:pskc ExpiryDate,omitempty"`
	PINPolicy            PINPolicyType  `xml:"urn:ietf:params:xml:ns:keyprov:pskc PINPolicy,omitempty"`
	KeyUsage             []KeyUsageType `xml:"urn:ietf:params:xml:ns:keyprov:pskc KeyUsage,omitempty"`
	NumberOfTransactions int            `xml:"urn:ietf:params:xml:ns:keyprov:pskc NumberOfTransactions,omitempty"`
}

func (t *PolicyType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T PolicyType
	var layout struct {
		*T
		StartDate  *xsdDateTime `xml:"urn:ietf:params:xml:ns:keyprov:pskc StartDate,omitempty"`
		ExpiryDate *xsdDateTime `xml:"urn:ietf:params:xml:ns:keyprov:pskc ExpiryDate,omitempty"`
	}
	layout.T = (*T)(t)
	layout.StartDate = (*xsdDateTime)(&layout.T.StartDate)
	layout.ExpiryDate = (*xsdDateTime)(&layout.T.ExpiryDate)
	return e.EncodeElement(layout, start)
}
func (t *PolicyType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T PolicyType
	var overlay struct {
		*T
		StartDate  *xsdDateTime `xml:"urn:ietf:params:xml:ns:keyprov:pskc StartDate,omitempty"`
		ExpiryDate *xsdDateTime `xml:"urn:ietf:params:xml:ns:keyprov:pskc ExpiryDate,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.StartDate = (*xsdDateTime)(&overlay.T.StartDate)
	overlay.ExpiryDate = (*xsdDateTime)(&overlay.T.ExpiryDate)
	return d.DecodeElement(&overlay, &start)
}

type RSAKeyValueType struct {
	Modulus  CryptoBinary `xml:"http://www.w3.org/2000/09/xmldsig# Modulus"`
	Exponent CryptoBinary `xml:"http://www.w3.org/2000/09/xmldsig# Exponent"`
}

type ReferenceList struct {
	DataReference ReferenceType `xml:"http://www.w3.org/2001/04/xmlenc# DataReference"`
	KeyReference  ReferenceType `xml:"http://www.w3.org/2001/04/xmlenc# KeyReference"`
}

type ReferenceType struct {
	Transforms   string `xml:"http://www.w3.org/2000/09/xmldsig# Transforms,omitempty"`
	DigestMethod string `xml:"http://www.w3.org/2000/09/xmldsig# DigestMethod"`
	DigestValue  string `xml:"http://www.w3.org/2000/09/xmldsig# DigestValue"`
	Id           string `xml:"Id,attr,omitempty"`
	URI          string `xml:"URI,attr,omitempty"`
	Type         string `xml:"Type,attr,omitempty"`
}

type ResponseFormat struct {
	Encoding    ValueFormatType `xml:"Encoding,attr"`
	Length      uint            `xml:"Length,attr"`
	CheckDigits bool            `xml:"CheckDigits,attr,omitempty"`
}

func (t *ResponseFormat) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ResponseFormat
	var overlay struct {
		*T
		CheckDigits *bool `xml:"CheckDigits,attr,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.CheckDigits = (*bool)(&overlay.T.CheckDigits)
	return d.DecodeElement(&overlay, &start)
}

type RetrievalMethodType struct {
	Transforms string `xml:"http://www.w3.org/2000/09/xmldsig# Transforms,omitempty"`
	URI        string `xml:"URI,attr,omitempty"`
	Type       string `xml:"Type,attr,omitempty"`
}

type SPKIDataType struct {
	Item     string `xml:",any"`
	SPKISexp []byte `xml:"http://www.w3.org/2000/09/xmldsig# SPKISexp"`
}

func (t *SPKIDataType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T SPKIDataType
	var layout struct {
		*T
		SPKISexp *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# SPKISexp"`
	}
	layout.T = (*T)(t)
	layout.SPKISexp = (*xsdBase64Binary)(&layout.T.SPKISexp)
	return e.EncodeElement(layout, start)
}
func (t *SPKIDataType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T SPKIDataType
	var overlay struct {
		*T
		SPKISexp *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# SPKISexp"`
	}
	overlay.T = (*T)(t)
	overlay.SPKISexp = (*xsdBase64Binary)(&overlay.T.SPKISexp)
	return d.DecodeElement(&overlay, &start)
}

type SignatureMethodType struct {
	Items            []string `xml:",any"`
	HMACOutputLength int      `xml:"http://www.w3.org/2000/09/xmldsig# HMACOutputLength,omitempty"`
	Algorithm        string   `xml:"Algorithm,attr"`
}

type SignaturePropertiesType struct {
	SignatureProperty []string `xml:"http://www.w3.org/2000/09/xmldsig# SignatureProperty"`
	Id                string   `xml:"Id,attr,omitempty"`
}

type SignaturePropertyType struct {
	Item   string `xml:",any"`
	Target string `xml:"Target,attr"`
	Id     string `xml:"Id,attr,omitempty"`
}

type SignatureType struct {
	SignedInfo     string   `xml:"http://www.w3.org/2000/09/xmldsig# SignedInfo"`
	SignatureValue string   `xml:"http://www.w3.org/2000/09/xmldsig# SignatureValue"`
	KeyInfo        string   `xml:"http://www.w3.org/2000/09/xmldsig# KeyInfo,omitempty"`
	Object         []string `xml:"http://www.w3.org/2000/09/xmldsig# Object,omitempty"`
	Id             string   `xml:"Id,attr,omitempty"`
}

type SignatureValueType struct {
	Value []byte `xml:",chardata"`
	Id    string `xml:"Id,attr,omitempty"`
}

func (t *SignatureValueType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T SignatureValueType
	var layout struct {
		*T
		Value *xsdBase64Binary `xml:",chardata"`
	}
	layout.T = (*T)(t)
	layout.Value = (*xsdBase64Binary)(&layout.T.Value)
	return e.EncodeElement(layout, start)
}
func (t *SignatureValueType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T SignatureValueType
	var overlay struct {
		*T
		Value *xsdBase64Binary `xml:",chardata"`
	}
	overlay.T = (*T)(t)
	overlay.Value = (*xsdBase64Binary)(&overlay.T.Value)
	return d.DecodeElement(&overlay, &start)
}

type SignedInfoType struct {
	CanonicalizationMethod string   `xml:"http://www.w3.org/2000/09/xmldsig# CanonicalizationMethod"`
	SignatureMethod        string   `xml:"http://www.w3.org/2000/09/xmldsig# SignatureMethod"`
	Reference              []string `xml:"http://www.w3.org/2000/09/xmldsig# Reference"`
	Id                     string   `xml:"Id,attr,omitempty"`
}

type StringDataType struct {
	PlainValue     string            `xml:"urn:ietf:params:xml:ns:keyprov:pskc PlainValue"`
	EncryptedValue EncryptedDataType `xml:"http://www.w3.org/2001/04/xmlenc# EncryptedValue"`
	ValueMAC       []byte            `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
}

func (t *StringDataType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T StringDataType
	var layout struct {
		*T
		ValueMAC *xsdBase64Binary `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
	}
	layout.T = (*T)(t)
	layout.ValueMAC = (*xsdBase64Binary)(&layout.T.ValueMAC)
	return e.EncodeElement(layout, start)
}
func (t *StringDataType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T StringDataType
	var overlay struct {
		*T
		ValueMAC *xsdBase64Binary `xml:"urn:ietf:params:xml:ns:keyprov:pskc ValueMAC,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.ValueMAC = (*xsdBase64Binary)(&overlay.T.ValueMAC)
	return d.DecodeElement(&overlay, &start)
}

type TransformType struct {
	Item      string `xml:",any"`
	XPath     string `xml:"http://www.w3.org/2000/09/xmldsig# XPath"`
	Algorithm string `xml:"Algorithm,attr"`
}

type TransformsType struct {
	Transform []string `xml:"http://www.w3.org/2000/09/xmldsig# Transform"`
}

type UpdateHistoryItemListType struct {
	UpdateHistoryItem []UpdateHistoryItemType `xml:"urn:dashif:org:cpix UpdateHistoryItem,omitempty"`
	Id                string                  `xml:"id,attr,omitempty"`
}

type UpdateHistoryItemType struct {
	Id            string    `xml:"id,attr,omitempty"`
	UpdateVersion int       `xml:"updateVersion,attr"`
	Index         string    `xml:"index,attr"`
	Source        string    `xml:"source,attr"`
	Date          time.Time `xml:"date,attr"`
}

func (t *UpdateHistoryItemType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T UpdateHistoryItemType
	var layout struct {
		*T
		Date *xsdDateTime `xml:"date,attr"`
	}
	layout.T = (*T)(t)
	layout.Date = (*xsdDateTime)(&layout.T.Date)
	return e.EncodeElement(layout, start)
}
func (t *UpdateHistoryItemType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T UpdateHistoryItemType
	var overlay struct {
		*T
		Date *xsdDateTime `xml:"date,attr"`
	}
	overlay.T = (*T)(t)
	overlay.Date = (*xsdDateTime)(&overlay.T.Date)
	return d.DecodeElement(&overlay, &start)
}

// May be one of DECIMAL, HEXADECIMAL, ALPHANUMERIC, BASE64, BINARY
type ValueFormatType string

// Must match the pattern \d{1,2}\.\d{1,3}
type VersionType string

type VideoFilterType struct {
	MinPixels int  `xml:"minPixels,attr,omitempty"`
	MaxPixels int  `xml:"maxPixels,attr,omitempty"`
	Hdr       bool `xml:"hdr,attr,omitempty"`
	Wcg       bool `xml:"wcg,attr,omitempty"`
	MinFps    int  `xml:"minFps,attr,omitempty"`
	MaxFps    int  `xml:"maxFps,attr,omitempty"`
}

type X509DataType struct {
	Item             string               `xml:",any"`
	X509IssuerSerial X509IssuerSerialType `xml:"http://www.w3.org/2000/09/xmldsig# X509IssuerSerial"`
	X509SKI          []byte               `xml:"http://www.w3.org/2000/09/xmldsig# X509SKI"`
	X509SubjectName  string               `xml:"http://www.w3.org/2000/09/xmldsig# X509SubjectName"`
	X509Certificate  []byte               `xml:"http://www.w3.org/2000/09/xmldsig# X509Certificate"`
	X509CRL          []byte               `xml:"http://www.w3.org/2000/09/xmldsig# X509CRL"`
}

func (t *X509DataType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T X509DataType
	var layout struct {
		*T
		X509SKI         *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# X509SKI"`
		X509Certificate *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# X509Certificate"`
		X509CRL         *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# X509CRL"`
	}
	layout.T = (*T)(t)
	layout.X509SKI = (*xsdBase64Binary)(&layout.T.X509SKI)
	layout.X509Certificate = (*xsdBase64Binary)(&layout.T.X509Certificate)
	layout.X509CRL = (*xsdBase64Binary)(&layout.T.X509CRL)
	return e.EncodeElement(layout, start)
}
func (t *X509DataType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T X509DataType
	var overlay struct {
		*T
		X509SKI         *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# X509SKI"`
		X509Certificate *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# X509Certificate"`
		X509CRL         *xsdBase64Binary `xml:"http://www.w3.org/2000/09/xmldsig# X509CRL"`
	}
	overlay.T = (*T)(t)
	overlay.X509SKI = (*xsdBase64Binary)(&overlay.T.X509SKI)
	overlay.X509Certificate = (*xsdBase64Binary)(&overlay.T.X509Certificate)
	overlay.X509CRL = (*xsdBase64Binary)(&overlay.T.X509CRL)
	return d.DecodeElement(&overlay, &start)
}

type X509IssuerSerialType struct {
	X509IssuerName   string `xml:"http://www.w3.org/2000/09/xmldsig# X509IssuerName"`
	X509SerialNumber int    `xml:"http://www.w3.org/2000/09/xmldsig# X509SerialNumber"`
}

type xsdBase64Binary []byte

func (b *xsdBase64Binary) UnmarshalText(text []byte) (err error) {
	*b, err = base64.StdEncoding.DecodeString(string(text))
	return
}
func (b xsdBase64Binary) MarshalText() ([]byte, error) {
	var buf bytes.Buffer
	enc := base64.NewEncoder(base64.StdEncoding, &buf)
	enc.Write([]byte(b))
	enc.Close()
	return buf.Bytes(), nil
}

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}
